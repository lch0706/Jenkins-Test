<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="kr.co.ktds.orchestra.mapper.DevMapper">

    <select id="getProgressList" resultType="kr.co.ktds.orchestra.dto.common.ProgressDevList">
        <![CDATA[
        -- getProgressList (누적/주간 진척 그리드)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value --regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             , module_name as mdl_nm
             , name as assigned
             -- 누적
             , acc_plan, acc_per, acc_prog, acc_dly
             , coalesce(round((acc_per::numeric/nullif(acc_plan,0)::numeric *100), 1), 0) as acc_cmp_rate
             -- 주간
             , week_plan, week_per, week_prog, week_dly
             , coalesce(round((week_per::numeric/nullif(week_plan,0)::numeric*100), 1), 0) as week_cmp_rate
             , all_res as all_res, all_total as all_total
          from (
                select module_name, name
                     , count(acc_plan) as acc_plan   -- 누적계획
                     , count(acc_per) as acc_per     -- 누적실적
                     , count(acc_prog) as acc_prog   -- 누적진행중
                     , count(acc_dly) as acc_dly     -- 누적지연
                     , count(coalesce(round((acc_per::numeric/nullif(acc_plan,0)::numeric *100), 1), 0)) as acc_cmp_rate
                     , count(week_plan) as week_plan -- 주간계획
                     , count(week_per) as week_per   -- 주간실적
                     , count(week_prog) as week_prog -- 주간진행중
                     , count(week_dly) as week_dly   -- 주간지연
                     , count(coalesce(round((week_per::numeric/nullif(week_plan,0)::numeric*100), 1), 0)) as week_cmp_rate
                     , count(all_res) as all_res -- 테스트단계잔여
                     , count(all_total) as all_total   -- 테스트단계전체
                from (
                      select ic.name as module_name
                           , u.firstname as name
                           , i.id
                           , case when i.start_date <= con.date_acc then i.id end as acc_plan-- 누적계획
                           , case when i.start_date <= con.date_acc
                                   and date_trunc('day', i.closed_on) <= con.date_acc
                                   and iss.is_closed
                                  then i.id end as acc_per -- 누적실적
                           , case when i.start_date <= con.date_acc
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_acc
                                        or iss.is_closed = false)
                                   and i.due_date >= con.date_acc
                                  then i.id end as acc_prog -- 누적진행중
                           , case when i.start_date <= con.date_acc
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_acc
                                        or iss.is_closed = false)
                                   and i.due_date < con.date_acc
                                  then i.id end as acc_dly -- 누적지연
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                  then i.id end as week_plan -- 주간계획
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and date_trunc('day', i.closed_on) <= con.date_to
                                   and iss.is_closed = true
                                  then i.id end as week_per -- 주간실적
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_to
                                        or iss.is_closed = false)
                                   and i.due_date >= con.date_to
                                  then i.id end as week_prog -- 주간진행중
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_to
                                        or iss.is_closed = false)
                                   and i.due_date < con.date_to
                                  then i.id end as week_dly -- 주간지연
                           , case when not (i.closed_on is not null and iss.is_closed)
                                  then i.id end as all_res -- 테스트단계잔여
                           , i.id as all_total -- 테스트단계전체
                           , i.status_id
                           , i.start_date
                           , i.due_date
                           , i.closed_on
                           , iss.is_closed
                        from issues i
                       cross join
                             (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                     to_date(#{endDate}, 'YYYY-MM-DD') date_to,
                                     to_date(#{accDate}, 'YYYY-MM-DD') date_acc) con
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                       where 1=1
                         and i.project_id in (select project_id::integer from params)
                         and i.tracker_id
                          -- 구현단계 유형
                          in (select regexp_split_to_table(program_id, ',')::integer
                                from params)
                         and i.status_id != (select status_cancel_id::integer from params)
                         -- 검색조건에 따라 다름(2가지)
                         and i.assigned_to_id is not null
                         and i.category_id is not null
        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and ic.name like '%'||#{keyword}||'%'
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and u.firstname like '%'||#{keyword}||'%'
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (ic.name like '%'||#{keyword}||'%'
                                 or u.firstname like '%'||#{keyword}||'%')
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
                        ) base
                group by module_name, name
                order by module_name, name
            ) sum
        ]]>
    </select>

    <select id="getProgressList2" resultType="kr.co.ktds.orchestra.dto.common.ProgressDevList">
        <![CDATA[
        -- getProgressList2 (dev2 누적/주간 진척 그리드)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value --regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             ,(select name as trk_nm from trackers where id = tracker_id)
             , module_name as mdl_nm
             , name as assigned
             -- 누적
             , acc_plan, acc_per, acc_prog, acc_dly
             , coalesce(round((acc_per::numeric/nullif(acc_plan,0)::numeric *100), 1), 0) as acc_cmp_rate
             -- 주간
             , week_plan, week_per, week_prog, week_dly
             , coalesce(round((week_per::numeric/nullif(week_plan,0)::numeric*100), 1), 0) as week_cmp_rate
             , all_res as all_res, all_total as all_total
          from (
                select module_name, name, tracker_id
                     , count(acc_plan) as acc_plan   -- 누적계획
                     , count(acc_per) as acc_per     -- 누적실적
                     , count(acc_prog) as acc_prog   -- 누적진행중
                     , count(acc_dly) as acc_dly     -- 누적지연
                     , count(coalesce(round((acc_per::numeric/nullif(acc_plan,0)::numeric *100), 1), 0)) as acc_cmp_rate
                     , count(week_plan) as week_plan -- 주간계획
                     , count(week_per) as week_per   -- 주간실적
                     , count(week_prog) as week_prog -- 주간진행중
                     , count(week_dly) as week_dly   -- 주간지연
                     , count(coalesce(round((week_per::numeric/nullif(week_plan,0)::numeric*100), 1), 0)) as week_cmp_rate
                     , count(all_res) as all_res -- 테스트단계잔여
                     , count(all_total) as all_total   -- 테스트단계전체
                from (
                      select ic.name as module_name, i.tracker_id
                           , u.firstname as name
                           , i.id
                           , case when i.start_date <= con.date_acc then i.id end as acc_plan-- 누적계획
                           , case when i.start_date <= con.date_acc
                                   and date_trunc('day', i.closed_on) <= con.date_acc
                                   and iss.is_closed
                                  then i.id end as acc_per -- 누적실적
                           , case when i.start_date <= con.date_acc
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_acc
                                        or iss.is_closed = false)
                                   and i.due_date >= con.date_acc
                                  then i.id end as acc_prog -- 누적진행중
                           , case when i.start_date <= con.date_acc
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_acc
                                        or iss.is_closed = false)
                                   and i.due_date < con.date_acc
                                  then i.id end as acc_dly -- 누적지연
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                  then i.id end as week_plan -- 주간계획
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and date_trunc('day', i.closed_on) <= con.date_to
                                   and iss.is_closed = true
                                  then i.id end as week_per -- 주간실적
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_to
                                        or iss.is_closed = false)
                                   and i.due_date >= con.date_to
                                  then i.id end as week_prog -- 주간진행중
                           , case when i.start_date <= con.date_to
                                   and i.due_date >= con.date_from
                                   and (i.closed_on is null
                                        or date_trunc('day', i.closed_on) > con.date_to
                                        or iss.is_closed = false)
                                   and i.due_date < con.date_to
                                  then i.id end as week_dly -- 주간지연
                           , case when not (i.closed_on is not null and iss.is_closed)
                                  then i.id end as all_res -- 테스트단계잔여
                           , i.id as all_total -- 테스트단계전체
                           , i.status_id
                           , i.start_date
                           , i.due_date
                           , i.closed_on
                           , iss.is_closed
                        from issues i
                       cross join
                             (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                     to_date(#{endDate}, 'YYYY-MM-DD') date_to,
                                     to_date(#{accDate}, 'YYYY-MM-DD') date_acc) con
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                       where 1=1
                         and i.project_id in (select project_id::integer from params)
                         and i.tracker_id
                          -- 구현단계 유형
                          in (select regexp_split_to_table(program_id, ',')::integer
                                from params)
                         and i.status_id != (select status_cancel_id::integer from params)
                         -- 검색조건에 따라 다름(2가지)
        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and ic.name like '%'||#{keyword}||'%'
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and u.firstname like '%'||#{keyword}||'%'
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("tracker")'>
                <![CDATA[
                            and i.tracker_id in (select id from trackers
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (ic.name like '%'||#{keyword}||'%'
                                 or u.firstname like '%'||#{keyword}||'%'
                                 or i.tracker_id in (select id from trackers
						                              where name like '%'||#{keyword}||'%'))
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
                        ) base
                group by module_name, tracker_id, name
                order by module_name, tracker_id, name
            ) sum
        ]]>
    </select>
    
    <select id="getModuleStatus" resultType="kr.co.ktds.orchestra.dto.common.WeeklyProgressStatus">
        <![CDATA[
        -- 모듈별 주간진척(getModuleStatus)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             , module_name as mdl_nm
             , tracker_name as trk_nm
             -- 주간
             , coalesce(week_plan, 0) as week_plan
             , coalesce(week_per, 0) as week_per
             , coalesce(week_prog, 0) as week_prog
             , coalesce(week_dly, 0) as week_dly
             ,week_plan_ids
             ,week_per_ids
             ,week_prog_ids
             ,week_dly_ids
        from (
              select module_name
                   , tracker_name
                   , count(id) as week_plan -- 주간 계획
                   , count(done_id) as week_per -- 주간 실적
                   , count(ing_id) as week_prog -- 주간진행중
                   , count(delay_id) as week_dly -- 주간지연
                   , string_agg(id::varchar, ',' order by id) week_plan_ids
                   , string_agg(done_id::varchar, ',' order by id) week_per_ids
                   , string_agg(ing_id::varchar, ',' order by id) week_prog_ids
                   , string_agg(delay_id::varchar, ',' order by id) week_dly_ids
                from (
                      select ic.name as module_name
                            , t.name as tracker_name
                            , u.firstname as name
                            , i.id
                            , case when date_trunc('day', i.closed_on) <= con.date_to
                                    and iss.is_closed = true
                                   then i.id end done_id
                            , case when (i.closed_on is null
                                     or date_trunc('day', i.closed_on) > con.date_to
                                     or iss.is_closed = false)
                                    and i.due_date >= con.date_to
                                   then i.id end ing_id
                            , case when (i.closed_on is null
                                     or date_trunc('day', i.closed_on) > con.date_to
                                     or iss.is_closed = false)
                                    and i.due_date < con.date_to
                                   then i.id end delay_id
                            , i.status_id
                            , i.start_date
                            , i.due_date
                            , i.closed_on
                            , iss.is_closed
                        from issues i
                        cross join
                                     (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                             to_date(#{endDate}, 'YYYY-MM-DD') date_to) con
                        left outer join trackers t on i.tracker_id = t.id
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                        where 1=1
                          and i.due_date >= con.date_from
                          and start_date <= con.date_to
                          and (i.project_id, i.tracker_id)
                           in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                          and i.status_id != (select status_cancel_id::integer from params) -- '취소' 상태 제외
                          and i.assigned_to_id is not null
                          and i.category_id is not null
                           -- '취소' 상태 제외
                    ]]>
                    <if test='keyword != null'>
                        <choose>
                            <when test='region.equalsIgnoreCase("module")'>
                                <![CDATA[
                                        and i.category_id in (select id from issue_categories
                                                               where name like '%'||#{keyword}||'%')
                            ]]>
                            </when>
                            <when test='region.equalsIgnoreCase("assigned")'>
                                <![CDATA[
                                        and i.assigned_to_id in (select id from users
                                                                  where firstname like '%'||#{keyword}||'%')
                            ]]>
                            </when>
                            <when test='region.equalsIgnoreCase("all")'>
                                <![CDATA[
                                        and (i.category_id in (select id from issue_categories
                                                               where name like '%'||#{keyword}||'%')
                                             or i.assigned_to_id in (select id from users
                                                                  where firstname like '%'||#{keyword}||'%'))
                            ]]>
                            </when>
                            <otherwise>
                            </otherwise>
                        </choose>
                    </if>
                    <![CDATA[
                        ) base
                group by tracker_name, module_name
            ) sum
            order by trk_nm, mdl_nm asc
        ]]>
    </select>

    <select id="getModuleStatus2" resultType="kr.co.ktds.orchestra.dto.common.WeeklyProgressStatus">
        <![CDATA[
        -- 모듈별 주간진척(getModuleStatus)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             , (select name as trk_nm from trackers where id = tracker_id)
             , module_name as mdl_nm
             -- 주간
             , coalesce(week_plan, 0) as week_plan
             , coalesce(week_per, 0) as week_per
             , coalesce(week_prog, 0) as week_prog
             , coalesce(week_dly, 0) as week_dly
             ,week_plan_ids
             ,week_per_ids
             ,week_prog_ids
             ,week_dly_ids
        from (
              select tracker_id, module_name
                   , count(id) as week_plan -- 주간 계획
                   , count(done_id) as week_per -- 주간 실적
                   , count(ing_id) as week_prog -- 주간진행중
                   , count(delay_id) as week_dly -- 주간지연
                   , string_agg(id::varchar, ',' order by id) week_plan_ids
                   , string_agg(done_id::varchar, ',' order by id) week_per_ids
                   , string_agg(ing_id::varchar, ',' order by id) week_prog_ids
                   , string_agg(delay_id::varchar, ',' order by id) week_dly_ids
                from (
                      select ic.name as module_name
                            , u.firstname as name
                            , i.id
                            , i.tracker_id
                            , case when date_trunc('day', i.closed_on) <= con.date_to
                                    and iss.is_closed = true
                                   then i.id end done_id
                            , case when (i.closed_on is null
                                     or date_trunc('day', i.closed_on) > con.date_to
                                     or iss.is_closed = false)
                                    and i.due_date >= con.date_to
                                   then i.id end ing_id
                            , case when (i.closed_on is null
                                     or date_trunc('day', i.closed_on) > con.date_to
                                     or iss.is_closed = false)
                                    and i.due_date < con.date_to
                                   then i.id end delay_id
                            , i.status_id
                            , i.start_date
                            , i.due_date
                            , i.closed_on
                            , iss.is_closed
                        from issues i
                        cross join
                                     (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                             to_date(#{endDate}, 'YYYY-MM-DD') date_to) con
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                        where 1=1
                          and i.due_date >= con.date_from
                          and start_date <= con.date_to
                          and (i.project_id, i.tracker_id)
                           in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                          and i.status_id not in (select regexp_split_to_table(status_cancel_id, ',')::integer from params) -- '취소' 상태 제외
                           -- '취소' 상태 제외
                    ]]>
                    <if test='keyword != null'>
                        <choose>
                            <when test='region.equalsIgnoreCase("tracker")'>
                            <![CDATA[
                                        and i.tracker_id in (select id from trackers
                                                            where name like '%'||#{keyword}||'%')
                            ]]>
                            </when>
                            <when test='region.equalsIgnoreCase("assigned")'>
                            <![CDATA[
                                        and i.assigned_to_id in (select id from users
                                                            where firstname like '%'||#{keyword}||'%')
                            ]]>
                            </when>
                            <when test='region.equalsIgnoreCase("all")'>
                            <![CDATA[
                                        and (i.tracker_id in (select id from trackers
                                                            where name like '%'||#{keyword}||'%')
                                            or i.assigned_to_id in (select id from users
                                                            where firstname like '%'||#{keyword}||'%'))
                            ]]>
                            </when>
                            <otherwise>
                            </otherwise>
                        </choose>
                    </if>
                    <![CDATA[
                        ) base
                group by tracker_id, module_name
            ) sum
        ]]>
    </select>

    <select id="getAssigneeStatus" resultType="kr.co.ktds.orchestra.dto.common.WeeklyProgressStatus">
        <![CDATA[
        --getAssigneeStatus
        -- (개발자별 주간진척)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             , name as assigned
             , week_plan, week_per, week_prog, week_dly
             , week_plan_ids, week_per_ids, week_prog_ids, week_dly_ids
          from (
                select name
                     , count(id) as week_plan -- 주간 계획
                     , count(done_id) as week_per -- 주간 실적
                     , count(ing_id) as week_prog -- 주간진행중
                     , count(delay_id) as week_dly -- 주간지연
                     , string_agg(id::varchar, ',' order by id) week_plan_ids
                     , string_agg(done_id::varchar, ',' order by id) week_per_ids
                     , string_agg(ing_id::varchar, ',' order by id) week_prog_ids
                     , string_agg(delay_id::varchar, ',' order by id) week_dly_ids
                  from (
                        select ic.name as module_name
                             , u.firstname as name
                             , i.id
                             , case when date_trunc('day', i.closed_on) <= con.date_to
                                     and iss.is_closed = true
                                    then i.id end done_id
                             , case when (i.closed_on is null
                                      or date_trunc('day', i.closed_on) > con.date_to
                                      or iss.is_closed = false)
                                     and i.due_date >= con.date_to
                                    then i.id end ing_id
                             , case when (i.closed_on is null
                                      or date_trunc('day', i.closed_on) > con.date_to
                                      or iss.is_closed = false)
                                     and i.due_date < con.date_to
                                    then i.id end delay_id
                             , i.status_id
                             , i.start_date
                             , i.due_date
                             , i.closed_on
                             , iss.is_closed
                        from issues i
                       cross join
                                     (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                             to_date(#{endDate}, 'YYYY-MM-DD') date_to) con
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                       where 1=1
                         and i.due_date >= con.date_from
                          and start_date <= con.date_to
                          and (i.project_id, i.tracker_id)
                           in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                          and i.status_id != (select status_cancel_id::integer from params) -- '취소' 상태 제외
                          and i.assigned_to_id is not null
                          and i.category_id is not null
                ]]>
                <if test='keyword != null'>
                    <choose>
                        <when test='region.equalsIgnoreCase("module")'>
                            <![CDATA[
                                and i.category_id in (select id from issue_categories
                                                       where name like '%'||#{keyword}||'%')
                            ]]>
                        </when>
                        <when test='region.equalsIgnoreCase("assigned")'>
                            <![CDATA[
                                and i.assigned_to_id in (select id from users
                                                          where firstname like '%'||#{keyword}||'%')
                            ]]>
                        </when>
                        <when test='region.equalsIgnoreCase("all")'>
                            <![CDATA[
                                and (i.category_id in (select id from issue_categories
                                                       where name like '%'||#{keyword}||'%')
                                     or i.assigned_to_id in (select id from users
                                                          where firstname like '%'||#{keyword}||'%'))
                            ]]>
                        </when>
                        <otherwise>
                        </otherwise>
                    </choose>
                </if>
                <![CDATA[
                       ) base
                 group by name
                 order by count(delay_id) desc
               ) sum
         -- limit 5
         order by week_dly desc, week_prog desc, week_per desc, week_plan desc, assigned asc
        ]]>
    </select>

    <select id="getAssigneeStatus2" resultType="kr.co.ktds.orchestra.dto.common.WeeklyProgressStatus">
        <![CDATA[
        -- getAssigneeStatus(개발자별 주간진척)
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select row_number() over() as no
             , name as assigned
             , week_plan, week_per, week_prog, week_dly
             , week_plan_ids, week_per_ids, week_prog_ids, week_dly_ids
          from (
                select name
                     , count(id) as week_plan -- 주간 계획
                     , count(done_id) as week_per -- 주간 실적
                     , count(ing_id) as week_prog -- 주간진행중
                     , count(delay_id) as week_dly -- 주간지연
                     , string_agg(id::varchar, ',' order by id) week_plan_ids
                     , string_agg(done_id::varchar, ',' order by id) week_per_ids
                     , string_agg(ing_id::varchar, ',' order by id) week_prog_ids
                     , string_agg(delay_id::varchar, ',' order by id) week_dly_ids
                  from (
                        select ic.name as module_name
                             , u.firstname as name
                             , i.id
                             , case when date_trunc('day', i.closed_on) <= con.date_to
                                     and iss.is_closed = true
                                    then i.id end done_id
                             , case when (i.closed_on is null
                                      or date_trunc('day', i.closed_on) > con.date_to
                                      or iss.is_closed = false)
                                     and i.due_date >= con.date_to
                                    then i.id end ing_id
                             , case when (i.closed_on is null
                                      or date_trunc('day', i.closed_on) > con.date_to
                                      or iss.is_closed = false)
                                     and i.due_date < con.date_to
                                    then i.id end delay_id
                             , i.status_id
                             , i.start_date
                             , i.due_date
                             , i.closed_on
                             , iss.is_closed
                        from issues i
                       cross join
                                     (select to_date(#{startDate}, 'YYYY-MM-DD') date_from,
                                             to_date(#{endDate}, 'YYYY-MM-DD') date_to) con
                        left outer join issue_categories ic on i.category_id = ic.id
                        left outer join issue_statuses iss on i.status_id = iss.id
                        left outer join users u on i.assigned_to_id = u.id
                       where 1=1
                         and i.due_date >= con.date_from
                          and start_date <= con.date_to
                          and (i.project_id, i.tracker_id)
                           in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                          and i.status_id not in (select regexp_split_to_table(status_cancel_id, ',')::integer from params) -- '취소' 상태 제외

                ]]>
                <if test='keyword != null'>
                    <choose>
                        <when test='region.equalsIgnoreCase("tracker")'>
                        <![CDATA[
                                    and i.tracker_id in (select id from trackers
                                                        where name like '%'||#{keyword}||'%')
                        ]]>
                        </when>
                        <when test='region.equalsIgnoreCase("module")'>
                        <![CDATA[
                                    and i.category_id in (select id from issue_categories
                                                            where name like '%'||#{keyword}||'%')
                        ]]>
                        </when>
                        <when test='region.equalsIgnoreCase("all")'>
                        <![CDATA[
                                    and (i.tracker_id in (select id from trackers
                                                        where name like '%'||#{keyword}||'%')
                                        or i.category_id in (select id from issue_categories
                                                            where name like '%'||#{keyword}||'%'))
                        ]]>
                        </when>
                        <otherwise>
                        </otherwise>
                    </choose>
                </if>
                <![CDATA[
                       ) base
                 group by name
                 order by count(delay_id) desc
               ) sum
         -- limit 5
        ]]>
    </select>

    <select id="getCompleteStatus" resultType="kr.co.ktds.orchestra.dto.common.CompleteStatus">
        <![CDATA[
        -- 누적 개발완료 현황
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select status
             , cnt
             , total
             , round(cnt/total::numeric * 100, 1) as ratio
             , ids as id
          from (
                select s.name status
                     , count(s.name) cnt
                     , sum(count(s.name)) over () total
                     , string_agg(i.id::varchar, ',' order by i.id) ids
                  from issues i
                  left outer join issue_statuses s on i.status_id = s.id
                 where 1=1
                   and (i.project_id, i.tracker_id)
                    in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                   and i.status_id != (select status_cancel_id::integer from params) -- '취소' 상태 제외
                   -- '취소' 상태 제외
                   and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                   and i.assigned_to_id is not null
                   and i.category_id is not null
        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                                 or i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%'))
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
                 group by s.name,s.is_closed
                 order by s.name asc
               ) obj
        ]]>
        
    </select>

    <select id="getCompleteStatus2" resultType="kr.co.ktds.orchestra.dto.common.CompleteStatus">
        <![CDATA[
        -- 누적 개발완료 현황
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select status
             , cnt
             , total
             , round(cnt/total::numeric * 100, 1) as ratio
             , ids
          from (
                select s.name status
                     , count(s.name) cnt
                     , sum(count(s.name)) over () total
                     , string_agg(i.id::varchar, ',' order by i.id) ids
                  from issues i
                  left outer join issue_statuses s on i.status_id = s.id
                 where 1=1
                   and (i.project_id, i.tracker_id)
                    in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
                   and i.status_id != (select status_cancel_id::integer from params) -- '취소' 상태 제외
                   -- '취소' 상태 제외
                   and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("tracker")'>
                <![CDATA[
                            and i.tracker_id in (select id from trackers
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                                 or i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                                 or i.tracker_id in (select id from trackers
						                           where name like '%'||#{keyword}||'%'))
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
                 group by s.name,s.is_closed
                 order by s.name
               ) obj
        ]]>
        
    </select>

    <select id="getProgressDetail" resultType="kr.co.ktds.orchestra.dto.dev.ProgressDetail">
        <![CDATA[
        -- 누적/주간 진척 그리드 모달 팝업
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select (row_number() over()) as no -- no
            , i.id					-- taskID
            , iss.name as status    -- 상태
            , ic.name as mdl_nm		-- 모듈
            , i.subject 	-- 제목
            , u.firstname as assignee -- 담당자
            , i.start_date			-- 시작일자
            , i.due_date as end_date  -- 종료일자
            , to_char(i.closed_on,'yyyy-mm-dd') as closed_date -- 완료일
            , i.done_ratio as done_ratio	   -- 진척도
        from issues i
        join issue_statuses iss   on i.status_id = iss.id
        join issue_categories ic  on i.category_id = ic.id
        join users u              on i.assigned_to_id = u.id	        
        where 1=1
          and (i.project_id, i.tracker_id)
           in (select project_id, program_id from params)
          and i.status_id != (select status_cancel_id from params) -- '취소' 상태 제외
        ]]>

        <if test="module != null">
            <![CDATA[
                and ic.name = #{module}
           ]]>
        </if>
        <if test="assignee != null">
            <![CDATA[
                and u.firstname = #{assignee}
           ]]>
        </if>
        <if test="type != null and type.equalsIgnoreCase('week')">
            <choose>
                <when test='status.equalsIgnoreCase("plan")'>
                    <![CDATA[
                    -- 주간계획
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
               <when test='status.equalsIgnoreCase("perform")'>
                   <![CDATA[
                    -- 주간실적
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and date_trunc('day', i.closed_on) <= to_date(#{endDate}, 'YYYY-MM-DD')   
                    and iss.is_closed = true
                    ]]>
               </when>
                <when test='status.equalsIgnoreCase("progress")'>
                   <![CDATA[
                    -- 주간진행중
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{endDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date >= to_date(#{endDate}, 'YYYY-MM-DD')
                    ]]>
               </when>
                <when test='status.equalsIgnoreCase("delay")'>
                    <![CDATA[
                    -- 주간지연
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{endDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date < to_date(#{endDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <if test="type != null and type.equalsIgnoreCase('acc')">
            <choose>
                <when test='status.equalsIgnoreCase("plan")'>
                    <![CDATA[
                    -- 누적계획
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <when test='status.equalsIgnoreCase("perform")'>
                    <![CDATA[
                    -- 누적실적
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and date_trunc('day', i.closed_on) <= to_date(#{accDate}, 'YYYY-MM-DD')  
                    and iss.is_closed = true
                   ]]>
                </when>
                <when test='status.equalsIgnoreCase("progress")'>
                    <![CDATA[
                    -- 누적진행중
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{accDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date >= to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>                
                <when test='status.equalsIgnoreCase("delay")'>
                    <![CDATA[
                    -- 누적지연     
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{accDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date < to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <if test="type != null and type.equalsIgnoreCase('res')">
           and not (i.closed_on is not null and iss.is_closed)
        </if>
    </select>

    <select id="getProgressDetail2" resultType="kr.co.ktds.orchestra.dto.dev.ProgressDetail">
        <![CDATA[
        -- 누적/주간 진척 그리드 모달 팝업
        with params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value as set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        )
        select (row_number() over()) as no -- no
            , i.id					-- taskID
            , (select name as trk_nm from trackers where id = i.tracker_id)
            , iss.name as status    -- 상태
            , ic.name as mdl_nm		-- 모듈
            , i.subject 	-- 제목
            , u.firstname as assigned -- 담당자
            , i.start_date			-- 시작일자
            , i.due_date as end_date  -- 종료일자
            , to_char(i.closed_on,'yyyy-mm-dd') as closed_date -- 완료일
            , i.done_ratio as done_ratio	   -- 진척도
        from issues i
        join issue_statuses iss   on i.status_id = iss.id
        join issue_categories ic  on i.category_id = ic.id
        join users u              on i.assigned_to_id = u.id	        
        where 1=1
          and (i.project_id, i.tracker_id)
           in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
          and i.status_id not in (select regexp_split_to_table(status_cancel_id, ',')::integer from params) -- '취소' 상태 제외
        ]]>

        <if test="module != null">
            <![CDATA[
                and ic.name = #{module}
           ]]>
        </if>
        <if test="assignee != null">
            <![CDATA[
                and u.firstname = #{assignee}
           ]]>
        </if>
        <if test="type != null and type.equalsIgnoreCase('week')">
            <choose>
                <when test='status.equalsIgnoreCase("plan")'>
                    <![CDATA[
                    -- 주간계획
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
               <when test='status.equalsIgnoreCase("perform")'>
                   <![CDATA[
                    -- 주간실적
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and date_trunc('day', i.closed_on) <= to_date(#{endDate}, 'YYYY-MM-DD')   
                    and iss.is_closed = true
                    ]]>
               </when>
                <when test='status.equalsIgnoreCase("progress")'>
                   <![CDATA[
                    -- 주간진행중
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{endDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date >= to_date(#{endDate}, 'YYYY-MM-DD')
                    ]]>
               </when>
                <when test='status.equalsIgnoreCase("delay")'>
                    <![CDATA[
                    -- 주간지연
                    and i.due_date >= to_date(#{startDate}, 'YYYY-MM-DD')
                    and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{endDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date < to_date(#{endDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <if test="type != null and type.equalsIgnoreCase('acc')">
            <choose>
                <when test='status.equalsIgnoreCase("plan")'>
                    <![CDATA[
                    -- 누적계획
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <when test='status.equalsIgnoreCase("perform")'>
                    <![CDATA[
                    -- 누적실적
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and date_trunc('day', i.closed_on) <= to_date(#{accDate}, 'YYYY-MM-DD')  
                    and iss.is_closed = true
                   ]]>
                </when>
                <when test='status.equalsIgnoreCase("progress")'>
                    <![CDATA[
                    -- 누적진행중
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{accDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date >= to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>                
                <when test='status.equalsIgnoreCase("delay")'>
                    <![CDATA[
                    -- 누적지연     
                    and i.start_date <= to_date(#{accDate}, 'YYYY-MM-DD')
                    and (i.closed_on is null
                        or date_trunc('day', i.closed_on) > to_date(#{accDate}, 'YYYY-MM-DD')
                        or iss.is_closed = false)
                    and i.due_date < to_date(#{accDate}, 'YYYY-MM-DD')
                   ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <if test="type != null and type.equalsIgnoreCase('res')">
           and not (i.closed_on is not null and iss.is_closed)
        </if>
    </select>


    <select id="getDailyStatus" resultType="kr.co.ktds.orchestra.dto.common.DailyStatus">
        <![CDATA[
        -- getDailyStatus (계획 대비 실적 일자별 개발현황 차트)
        with recursive copy_t(base_date)
        as (
            select to_date(#{startDate}, 'YYYY-MM-DD')
            union all
            select base_date + 1 from copy_t
            where base_date < to_date(#{endDate}, 'YYYY-MM-DD')
        ),
        params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        ),
        prgm as (
            select i.id, i.start_date,
                   case when i.closed_on is not null and s.is_closed then i.closed_on::date end closed_date
            from issues i
           inner join issue_statuses s
              on (i.status_id = s.id)
            where 1=1
              and (i.project_id, i.tracker_id)
               in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
              and i.status_id != (select status_cancel_id::integer from params) -- '취소' 상태 제외
            and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD') --  조회종료일자
            and i.assigned_to_id is not null
            and i.category_id is not null
        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                                 or i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%'))
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
        )
        select g.base_date, count(start_date) plan_cnt,
            count(case when closed_date <= base_date then 1 end) done_cnt,
            string_agg(g.id::varchar, ',' order by g.id) plan_list,
            string_agg(case when closed_date <= base_date then g.id::varchar end, ',' order by g.id) done_list
        from (
                select lft.base_date, rgt.*
                from copy_t lft
                left outer join prgm rgt
                    on (rgt.start_date <= lft.base_date)
            ) g
        group by g.base_date
        order by g.base_date
        ]]>
    </select>

    <select id="getDailyStatus2" resultType="kr.co.ktds.orchestra.dto.common.DailyStatus">
        <![CDATA[
        -- getDailyStatus (계획 대비 실적 일자별 개발현황 차트)
        with recursive copy_t(base_date)
        as (
            select to_date(#{startDate}, 'YYYY-MM-DD')
            union all
            select base_date + 1 from copy_t
            where base_date < to_date(#{endDate}, 'YYYY-MM-DD')
        ),
        params as
        (
        select max(sr.project_id) project_id,
               max(case sr.set_name when 'tracker_id.program2' then sr.set_value end) program_id,
               max(case sr.set_name when 'status.cancel' then sr.set_value end) status_cancel_id,
               max(case sr.set_name when 'status.done' then sr.set_value end) status_done_id
          from (
                select first_value(r.set_value) over (order by r.project_id)::integer curr_proj_id,
                       s.set_name,
                       r.project_id,
                       r.set_value--regexp_split_to_table(r.set_value, ',')::integer set_value
                  from or_set_bas s
                  left outer join or_prj_set_rel r
                    on (s.id = r.set_id)
                 where (s.set_name, s.is_project_dependent)
                    in (('project_id.current', false),
                        ('tracker_id.program2', true),
                        ('status.cancel', true),
                        ('status.done', true)
                       ) -- 프로그램
               ) sr
         where sr.curr_proj_id = sr.project_id
        ),
        prgm as (
            select i.id, i.start_date,
                   case when i.closed_on is not null and s.is_closed then i.closed_on::date end closed_date
            from issues i
           inner join issue_statuses s
              on (i.status_id = s.id)
            where 1=1
              and (i.project_id, i.tracker_id)
               in (select project_id::integer, regexp_split_to_table(program_id, ',')::integer from params)
              and i.status_id not in (select regexp_split_to_table(status_cancel_id, ',')::integer from params) -- '취소' 상태 제외
            and i.start_date <= to_date(#{endDate}, 'YYYY-MM-DD') --  조회종료일자

        ]]>
        <if test='keyword != null'>
            <choose>
                <when test='region.equalsIgnoreCase("module")'>
                <![CDATA[
                            and i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("assigned")'>
                <![CDATA[
                            and i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("tracker")'>
                <![CDATA[
                            and i.tracker_id in (select id from trackers
						                           where name like '%'||#{keyword}||'%')
                ]]>
                </when>
                <when test='region.equalsIgnoreCase("all")'>
                <![CDATA[
                            and (i.category_id in (select id from issue_categories
						                           where name like '%'||#{keyword}||'%')
                                 or i.assigned_to_id in (select id from users
                                                      where firstname like '%'||#{keyword}||'%')
                                 or i.tracker_id in (select id from trackers
						                           where name like '%'||#{keyword}||'%'))
                ]]>
                </when>
                <otherwise>
                </otherwise>
            </choose>
        </if>
        <![CDATA[
        )
        select g.base_date, count(start_date) plan_cnt,
            count(case when closed_date <= base_date then 1 end) done_cnt,
            string_agg(g.id::varchar, ',' order by g.id) plan_list,
            string_agg(case when closed_date <= base_date then g.id::varchar end, ',' order by g.id) done_list
        from (
                select lft.base_date, rgt.*
                from copy_t lft
                left outer join prgm rgt
                    on (rgt.start_date <= lft.base_date)
            ) g
        group by g.base_date
        order by g.base_date
        ]]>
    </select>
</mapper>